// A shared library for running the snake 6025
// with the nes-core virtual CPU
//
// This is for testing the nes-core virtual 6502 CPU

extern "C" {
    /// Imported function to read random number generator
    #[link_name = "rng"]
    fn ffi_rng() -> u8;
    /// Imported function to read button input
    #[link_name = "btn"]
    fn ffi_btn() -> u8;
    /// Imported function to render graphics
    #[link_name = "render"]
    fn ffi_render(buffer: *const u8, length: usize);
    /// Imported function to reset the game
    #[link_name = "game_reset"]
    fn ffi_reset();
}

// Safe wrappers sround imported ffi functions

fn rng() -> u8 {
    unsafe { ffi_rng() }
}

fn btn() -> u8 {
    unsafe { ffi_btn() }
}

fn reset() {
    unsafe { ffi_reset() }
}

fn render(buffer: &[u8]) {
    unsafe {
        ffi_render(buffer.as_ptr(), buffer.len());
    }
}

// Exported ffi functions

static mut GAME: Game = Game::new();

#[export_name = "get_game_memory"]
pub extern "C" fn ffi_get_game_memory() -> *mut u8 {
    unsafe {
        GAME.cpu.bus.memory.as_mut_ptr()
    }
}

#[export_name = "step"]
pub extern "C" fn ffi_step() -> u8 {
    unsafe {
        GAME.step()
    }
}

use nes_core::{rp2a0x::CPU, Bus, Tick};

pub struct Game {
    pub cpu: CPU<GameBus>,
}

impl Game {
    pub const fn new() ->Self {
        let start_address = 0x0600u16;
        let bus = GameBus::new();
        let cpu = CPU::new(bus, start_address);
        Self { cpu }
    }
    pub fn step(&mut self) -> u8 {
        self.cpu.tick()
    }
}

pub struct GameBus {
    memory: [u8; 0x0600]
}

impl GameBus {
    pub const fn new() -> Self {
        let memory = [0u8; 0x0600];
        Self { memory }
    }
}

impl Bus for GameBus {
    fn read(&self, address: u16) -> u8 {
        if address < 0x0600 {
            if address == 0x00FE {
                rng()
            } else if address == 0x00FF {
                btn()
            } else {
                self.memory[address as usize]
            }
        } else if 0x0600 <= address && (address < (0x0600 + GAME_CODE.len()) as u16) {
            GAME_CODE[(address - 0x0600) as usize]
        } else {
            reset();
            0
        }
    }

    fn write(&mut self, address: u16, data: u8) {
        self.memory[address as usize] = data;
        if 0x0200 <= address && address < 0x0600 {
            render(&mut self.memory[0x0200..0x0600]);
        }
    }
}

const GAME_CODE: [u8; 309] = [
    0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02, 0x85,
    0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85,
    0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
    0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3,
    0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9,
    0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
    0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0,
    0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02,
    0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
    0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07,
    0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06,
    0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
    0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02,
    0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9,
    0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
    0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0,
    0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29,
    0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
    0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa2, 0x00, 0xea,
    0xea, 0xca, 0xd0, 0xfb, 0x60,
];